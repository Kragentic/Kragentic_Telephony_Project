{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Elixir & Python Monorepo",
        "description": "Create a modular monolith repository structure with Elixir umbrella app for telephony and Python service for AI orchestration",
        "details": "Set up Elixir umbrella project with apps: telephony, core, web. Create Python service in /services/ai_orchestrator with Poetry. Add .tool-versions, Dockerfile, docker-compose.yml for local dev. Configure mix.exs with required deps: phoenix, livekit, twilio, postgrex. Python deps: langchain, openai, anthropic, google-cloud-speech, gtts, pyttsx3, elevenlabs.",
        "testStrategy": "Verify mix deps.get and poetry install succeed. Run mix test and pytest to ensure empty test suites pass.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Setup Fly.io Infrastructure",
        "description": "Configure Fly.io deployment with multi-region setup and autoscaling",
        "details": "Create fly.toml with [env] vars for DATABASE_URL, SECRET_KEY_BASE, TWILIO_SID, TWILIO_TOKEN, LIVEKIT_API_KEY, LIVEKIT_SECRET, OPENAI_API_KEY, ANTHROPIC_API_KEY. Configure [http_service] with internal_port=4000, force_https=true. Add [deploy] release_command='mix ecto.migrate'. Create .github/workflows/fly.yml for CI/CD. Set up fly regions: lax, ord, fra.",
        "testStrategy": "Deploy to fly.io staging app and verify health check passes at https://staging-app.fly.dev/health",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Setup PostgreSQL Database",
        "description": "Create database schema for calls, contacts, campaigns, consent logs, and analytics",
        "details": "Create migrations: create_calls_table (id, twilio_sid, direction, status, recording_url, consent_granted, inserted_at, updated_at), create_contacts_table (id, phone, name, metadata, blacklisted, inserted_at), create_campaigns_table (id, name, config, status, inserted_at), create_consent_logs_table (id, call_id, granted, timestamp), create_analytics_table (id, metric, value, date). Add indexes on twilio_sid, phone, timestamp.",
        "testStrategy": "Run mix ecto.migrate and verify all tables exist. Seed with test data and query via psql.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Integrate Twilio Webhooks",
        "description": "Implement Twilio webhook handlers for inbound call events",
        "details": "Create /api/twilio/webhook controller in Elixir. Handle /voice for inbound calls, /status for status callbacks. Parse Twilio params: CallSid, From, To, CallStatus. Return TwiML response with <Say> for greeting and <Gather> for consent. Store call record in DB with pending status. Add webhook signature validation using twilio_auth_token.",
        "testStrategy": "Use ngrok to expose local dev. Send test webhook from Twilio console and verify 200 response with correct TwiML.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Setup LiveKit Real-time Audio",
        "description": "Configure LiveKit for real-time voice streaming between Twilio and AI agent",
        "details": "Install livekit-server via Docker. Create livekit.yaml with keys for API key/secret. In Elixir, add livekit_ex dependency. Create LiveKit.Room module to manage audio streams. Implement token generation for participants. Create audio bridge between Twilio <Stream> and LiveKit room. Handle audio format conversion (PCM 16kHz).",
        "testStrategy": "Use LiveKit's test client to join room. Verify audio packets flow and latency <300ms.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Consent Flow",
        "description": "Build consent collection system with recording controls",
        "details": "Create Consent module with ask_for_consent/1 function. Play pre-recorded message: 'This call may be recorded for quality purposes. Press 1 to consent, 2 to decline'. On keypress 1: update call record consent_granted=true, start recording via Twilio <Record>. On keypress 2: continue without recording. Log consent decision in consent_logs table. Handle timeout after 10s as implicit decline.",
        "testStrategy": "Call Twilio number, verify prompt plays. Press 1 and check recording starts. Press 2 and verify no recording URL saved.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create STT Service",
        "description": "Implement Speech-to-Text using Google Speech API",
        "details": "Python service: create stt.py with GoogleSpeechClient. Config: language_code='en-US', sample_rate_hertz=16000, encoding=LINEAR16. Stream audio from LiveKit via WebRTC. Implement real-time transcription with interim results. Return transcript chunks via WebSocket to Elixir. Handle profanity filtering - if contains ['fuck', 'shit', 'bitch'], trigger blacklist flow.",
        "testStrategy": "Send audio file with curse words. Verify transcript contains filtered text and blacklist API triggered.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create TTS Service",
        "description": "Implement Text-to-Speech with gTTS fallback and ElevenLabs option",
        "details": "Python service: create tts.py with providers: GoogleTTS (gtts), ElevenLabsTTS. Config via env: TTS_PROVIDER, ELEVENLABS_API_KEY, ELEVENLABS_VOICE_ID. Cache generated audio in Redis with TTL=1hr. Stream audio back to LiveKit. Handle rate limiting with exponential backoff. Fallback to gTTS if ElevenLabs fails.",
        "testStrategy": "Generate 'Hello, how can I help you?' via both providers. Verify audio plays correctly and is cached.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build LangChain AI Agent",
        "description": "Create conversational AI agent using LangChain and OpenAI",
        "details": "Python service: create agent.py with ConversationChain. Use ChatOpenAI(model='gpt-4-turbo-preview'). System prompt: 'You are a helpful AI assistant. Be concise, friendly, and professional.' Implement memory with ConversationBufferMemory. Add tools: get_customer_info(phone), update_contact_notes. Handle max_tokens=150, temperature=0.7.",
        "testStrategy": "Test conversation flow: 'What's your refund policy?' -> verify coherent response. Check memory persists context.",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement RAG Augmentation",
        "description": "Add Retrieval-Augmented Generation using vector database",
        "details": "Python service: create rag.py with Chroma vector store. Use OpenAIEmbeddings for document encoding. Store FAQ, product info, policies as documents. Implement similarity search with top_k=3. Inject retrieved context into agent prompt. Update vector store via admin API at /admin/rag/upload.",
        "testStrategy": "Upload 'Our refund policy is 30 days'. Ask 'How long for refunds?' -> verify agent uses RAG context.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create Contact List Manager",
        "description": "Build system for managing contact lists and campaigns",
        "details": "Elixir: create ContactManager context with CRUD for contacts. CSV import endpoint /api/contacts/import. Schema validation: phone (E.164 format), name, metadata JSON. Add scheduling: process_contact/2 with delay via Oban job queue. Implement retry logic: max_attempts=3, exponential backoff.",
        "testStrategy": "Upload CSV with 100 contacts. Verify all imported correctly. Test retry after failed call.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Build Campaign Engine",
        "description": "Implement outbound campaign system with rules",
        "details": "Elixir: create CampaignEngine with schema: campaigns(id, name, type, config, status, schedule). Config JSON: {dial_rate: 10, retry_attempts: 3, time_window: {start: '09:00', end: '17:00'}}. Implement CampaignRunner GenServer that polls for active campaigns. Use Quantum for cron scheduling. Track metrics: attempted, connected, converted.",
        "testStrategy": "Create test campaign with 5 contacts. Verify calls initiated at correct rate and retry logic works.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Blacklist System",
        "description": "Handle profanity detection and automatic blacklisting",
        "details": "Elixir: create Blacklist module. On STT profanity detection: immediately play 'This call is being terminated due to inappropriate language', hang up via Twilio <Hangup>. Add phone to blacklist table with reason='profanity'. Check blacklist before processing any call. Admin API to view/remove from blacklist.",
        "testStrategy": "Call from test number, use profanity in STT. Verify call ends and number blacklisted. Try calling again - should be blocked.",
        "priority": "medium",
        "dependencies": [
          7,
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Build Analytics Pipeline",
        "description": "Create system for collecting and storing call analytics",
        "details": "Elixir: create Analytics context. Track events: call_started, call_ended, consent_given, recording_saved, agent_handoff. Store in analytics table with JSON metadata. Implement real-time counters via GenServer. Create daily aggregation job. Metrics: total_calls, avg_duration, consent_rate, blacklist_rate.",
        "testStrategy": "Make 10 test calls with various outcomes. Verify analytics reflect correct counts and rates.",
        "priority": "medium",
        "dependencies": [
          6,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create Admin Dashboard",
        "description": "Build React dashboard for system management",
        "details": "React app in /admin with Vite. Pages: Dashboard (real-time metrics), Contacts (CRUD), Campaigns (create/edit), Analytics (charts), RAG Management (upload docs). Use Tailwind for styling, Recharts for graphs. Connect via REST API: /api/dashboard/metrics, /api/contacts, /api/campaigns. Implement role-based auth with JWT.",
        "testStrategy": "Navigate all pages, verify data loads. Create campaign via UI and verify backend receives request.",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Human Fallback",
        "description": "Add routing to human agents when AI fails",
        "details": "Elixir: create FallbackRouter. Config: fallback_enabled=true, agent_webhook_url. On AI error (timeout, API failure), play 'Transferring to human agent'. Send POST to webhook with call details. Wait for agent to join LiveKit room. If no response in 30s, send to voicemail with Twilio <Record>.",
        "testStrategy": "Simulate OpenAI API failure. Verify transfer webhook called and agent can join call.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Add Security Layer",
        "description": "Implement authentication and encryption",
        "details": "Elixir: add Guardian for JWT auth. Create User schema with roles: admin, agent. Encrypt sensitive data: phone numbers (AES-256), recordings (server-side encryption). Add rate limiting via PlugAttack: 100 requests/minute per IP. Use Cloudflare for DDoS protection. HTTPS only with HSTS headers.",
        "testStrategy": "Test JWT token generation/validation. Verify encrypted phone numbers can't be read in DB. Test rate limiting blocks after threshold.",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Setup Monitoring & Alerting",
        "description": "Configure observability for production",
        "details": "Add Telemetry events for all key operations. Integrate Sentry for error tracking. Create Grafana dashboards: call_volume, error_rate, response_time. Add Prometheus metrics: ai_response_time, stt_accuracy, tts_latency. Configure alerts: error_rate > 1%, call_drop_rate > 5%.",
        "testStrategy": "Trigger test error and verify appears in Sentry. Check metrics appear in Grafana dashboard.",
        "priority": "low",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Create API Documentation",
        "description": "Document all public APIs with examples",
        "details": "Use OpenAPI 3.0 spec. Document endpoints: POST /api/twilio/webhook, GET /api/contacts, POST /api/campaigns, GET /api/analytics. Include request/response examples. Generate docs via Swagger UI at /docs. Add Postman collection for testing.",
        "testStrategy": "Import OpenAPI spec into Postman. Test all endpoints via collection runner.",
        "priority": "low",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Production Deployment",
        "description": "Deploy to production with final configurations",
        "details": "Create production fly.toml with scaled memory: memory=1024. Set secrets: flyctl secrets set from .env.prod. Run migrations: fly deploy --strategy=immediate. Configure Cloudflare DNS with A record pointing to Fly.io IP. Set up SSL certificate via Cloudflare. Enable HTTP/2 and Brotli compression.",
        "testStrategy": "Verify https://app.yourdomain.com loads. Run end-to-end test call. Check all metrics in Grafana.",
        "priority": "high",
        "dependencies": [
          17,
          18,
          19
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-19T11:40:00.239Z",
      "updated": "2025-08-20T13:24:57.240Z",
      "description": "Tasks for master context"
    }
  }
 
}
